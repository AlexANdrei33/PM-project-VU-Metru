#include <arduinoFFT.h>
#include <MD_Parola.h>
#include <MD_MAX72xx.h>
#include <SPI.h>
#include <dht.h>
#include <virtuabotixRTC.h>

#define NEXT_BUTTON 2
#define DHT_SENSOR 3
#define MAX_MODES 5
#define LDR A3

MD_MAX72XX disp = MD_MAX72XX(MD_MAX72XX::FC16_HW, 10, 4);
MD_Parola myDisplay = MD_Parola(MD_MAX72XX::FC16_HW, 10, 4);
arduinoFFT FFT = arduinoFFT();
dht DHT;
virtuabotixRTC myRTC(6, 7, 8);

volatile int mode = 0;        // Current mode
volatile unsigned long lastInt = 0;
int LDR_value = 0;


double realComponent[64];
double imagComponent[64];


int spectralHeight[] = {0b00000000,0b10000000,0b11000000,


                        0b11100000,0b11110000,0b11111000,


                        0b11111100,0b11111110,0b11111111};

// Sprite definitions:
const uint8_t F_PMAN1 = 6;
const uint8_t W_PMAN1 = 8;
const uint8_t PROGMEM pacman1[F_PMAN1 * W_PMAN1] =  // gobbling pacman animation
{
  0x00, 0x81, 0xc3, 0xe7, 0xff, 0x7e, 0x7e, 0x3c,
  0x00, 0x42, 0xe7, 0xe7, 0xff, 0xff, 0x7e, 0x3c,
  0x24, 0x66, 0xe7, 0xff, 0xff, 0xff, 0x7e, 0x3c,
  0x3c, 0x7e, 0xff, 0xff, 0xff, 0xff, 0x7e, 0x3c,
  0x24, 0x66, 0xe7, 0xff, 0xff, 0xff, 0x7e, 0x3c,
  0x00, 0x42, 0xe7, 0xe7, 0xff, 0xff, 0x7e, 0x3c,
};

const uint8_t F_PMAN2 = 6;
const uint8_t W_PMAN2 = 18;
const uint8_t PROGMEM pacman2[F_PMAN2 * W_PMAN2] =  // pacman pursued by a ghost
{
  0x00, 0x81, 0xc3, 0xe7, 0xff, 0x7e, 0x7e, 0x3c, 0x00, 0x00, 0x00, 0xfe, 0x7b, 0xf3, 0x7f, 0xfb, 0x73, 0xfe,
  0x00, 0x42, 0xe7, 0xe7, 0xff, 0xff, 0x7e, 0x3c, 0x00, 0x00, 0x00, 0xfe, 0x7b, 0xf3, 0x7f, 0xfb, 0x73, 0xfe,
  0x24, 0x66, 0xe7, 0xff, 0xff, 0xff, 0x7e, 0x3c, 0x00, 0x00, 0x00, 0xfe, 0x7b, 0xf3, 0x7f, 0xfb, 0x73, 0xfe,
  0x3c, 0x7e, 0xff, 0xff, 0xff, 0xff, 0x7e, 0x3c, 0x00, 0x00, 0x00, 0xfe, 0x7b, 0xf3, 0x7f, 0xfb, 0x73, 0xfe,
  0x24, 0x66, 0xe7, 0xff, 0xff, 0xff, 0x7e, 0x3c, 0x00, 0x00, 0x00, 0xfe, 0x7b, 0xf3, 0x7f, 0xfb, 0x73, 0xfe,
  0x00, 0x42, 0xe7, 0xe7, 0xff, 0xff, 0x7e, 0x3c, 0x00, 0x00, 0x00, 0xfe, 0x7b, 0xf3, 0x7f, 0xfb, 0x73, 0xfe,
};

const uint8_t F_WAVE = 14;
const uint8_t W_WAVE = 14;
const uint8_t PROGMEM wave[F_WAVE * W_WAVE] =  // triangular wave / worm
{
  0x08, 0x04, 0x02, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x40, 0x20, 0x10,
  0x10, 0x08, 0x04, 0x02, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x40, 0x20,
  0x20, 0x10, 0x08, 0x04, 0x02, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x40,
  0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,
  0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40,
  0x40, 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20,
  0x20, 0x40, 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01, 0x02, 0x04, 0x08, 0x10,
  0x10, 0x20, 0x40, 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01, 0x02, 0x04, 0x08,
  0x08, 0x10, 0x20, 0x40, 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01, 0x02, 0x04,
  0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01, 0x02,
  0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01,
  0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02,
  0x02, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x40, 0x20, 0x10, 0x08, 0x04,
  0x04, 0x02, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x40, 0x20, 0x10, 0x08,
};

int index, c, value;

void change() {
  unsigned long currentMillis = millis();
  
  // Debounce the button
  if (currentMillis - lastInt > 50) {
    // Update the mode
    mode += 1;
    if (mode >= MAX_MODES)
      mode = 0;

    if (mode == 1) {
      myDisplay.setSpriteData(pacman2, W_PMAN2, F_PMAN2, pacman2, W_PMAN2, F_PMAN2);
      myDisplay.displayText("Hello", PA_CENTER, 50, 1000, PA_SPRITE, PA_SPRITE);
    }

    lastInt = currentMillis;
  }
}

void setup() {
  x 

  disp.begin();
  myDisplay.begin();
  myDisplay.setIntensity(0);
  myDisplay.displayClear();
  Serial.begin(9600);
  // myRTC.setDS1302Time(55, 16, 0, 7, 28, 5, 2023);
}

void loop() {
  float alpha = 0.2;  // Smoothing factor
  int rawValue = analogRead(LDR);
  LDR_value = alpha * rawValue + (1 - alpha) * LDR_value;

  int intensity = LDR_value / 100;
  myDisplay.setIntensity(intensity);
  // Serial.println(new_intensity);

  if (mode == 0) {
    int sensitivity = map(analogRead(A0),0,1023,50,100); 

    // Serial.println (analogRead(A0));

    for(int i=0; i<64; i++) {
      realComponent[i] = analogRead(A0)/sensitivity;
      imagComponent[i] = 0;
    }


    FFT.Windowing(realComponent, 64, FFT_WIN_TYP_HAMMING, FFT_FORWARD);
    FFT.Compute(realComponent, imagComponent, 64, FFT_FORWARD);
    FFT.ComplexToMagnitude(realComponent, imagComponent, 64);

    for(int i=0; i<32; i++) {
      realComponent[i] = constrain(realComponent[i],0,80);
      realComponent[i] = map(realComponent[i],0,80,0,8);

      index = realComponent[i];
      value = spectralHeight[index];

      c = 31 - i;

      disp.setColumn(c, value);
    }
  } else if (mode == 1) {
    if (myDisplay.displayAnimate()) {
      myDisplay.displayReset();
    }
  } else if (mode == 2) {
    int readData = DHT.read11(DHT_SENSOR);

    float t = DHT.temperature;        // Read temperature

    myDisplay.setTextAlignment(PA_CENTER);
    int t_rounded = round(t);
    myDisplay.print((String)t_rounded+"*C");
  
    //myDisplay.print(tempC,0);
    delay(1000);
  } else if (mode == 3) {
    int readData = DHT.read11(DHT_SENSOR);

    float h = DHT.humidity;

    myDisplay.setTextAlignment(PA_CENTER);
    int h_rounded = round(h);
    myDisplay.print((String)h_rounded+"%");
    delay(1000);
  } else if (mode == 4) {
    myRTC.updateTime();

    int hours = myRTC.hours;
    int minutes = myRTC.minutes;
    myDisplay.setTextAlignment(PA_CENTER);

    String time = (String)hours + ":" + (String)minutes;

    if (hours >= 0 && hours <= 9) {
      time = "0" + time;
    }

    if (minutes >= 0 && minutes <= 9) {
      time = (String)hours + ":" + "0" + (String)minutes;
    }
    

    myDisplay.print(time);
    delay(1000);
  }
}